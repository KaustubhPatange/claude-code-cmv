# CMV v2.0.0 Plan

Two features: auto-trim via Claude Code's `PreCompact` hook, and batch branching with session status in the TUI. Lays the groundwork for v3.0.0's embedded parallel sessions.

---

## Feature 1: Auto-Trim Hook

### What it does

CMV registers a `PreCompact` hook with Claude Code. When compaction is about to fire (auto or manual), the hook trims the session JSONL before compaction reads it. The mechanical overhead is gone before the summariser ever sees it, so compaction produces a higher quality summary from clean signal instead of 60-70% tool result noise.

### How Claude Code hooks work

Claude Code has a lifecycle hook system configured in `.claude/settings.json` or `~/.claude/settings.json`. Hooks are shell commands that run at specific events. The relevant event is `PreCompact`, which fires before context compaction. It receives JSON on stdin with:

```json
{
  "session_id": "abc123",
  "transcript_path": "/path/to/session.jsonl",
  "trigger": "auto",
  "cwd": "/project/dir"
}
```

`PreCompact` **cannot block compaction** (it always proceeds), but we can modify the transcript file before compaction reads it. We can also create a backup snapshot before any modification happens.

### Implementation

#### 1. New command: `cmv hook install`

Registers the PreCompact hook in the user's Claude Code settings.

**File: `src/commands/hook.ts`**

```
cmv hook install          # install the PreCompact auto-trim hook
cmv hook uninstall        # remove it
cmv hook status           # show whether installed, last trim stats
```

`install` does the following:
- Read `~/.claude/settings.json` (create if missing)
- Add to `hooks.PreCompact`:

```json
{
  "hooks": {
    "PreCompact": [
      {
        "matcher": "auto",
        "hooks": [
          {
            "type": "command",
            "command": "cmv auto-trim",
            "timeout": 30,
            "statusMessage": "CMV: trimming context before compaction..."
          }
        ]
      }
    ]
  }
}
```

- `matcher: "auto"` means it only fires on auto-compaction, not manual `/compact`. Manual compact is intentional. Auto-compact is the one that catches people off guard.
- The hook calls `cmv auto-trim`, a new hidden command.

Options for `install`:
- `--all` to match both `auto` and `manual` triggers
- `--threshold <chars>` to set trim aggressiveness (written to CMV config, read by auto-trim at runtime)

#### 2. New command: `cmv auto-trim` (hidden, not shown in help)

This is the command the hook actually calls. It reads JSON from stdin (the hook input), performs the trim, and exits.

**File: `src/commands/auto-trim.ts`**

Flow:
1. Read JSON from stdin (hook provides `transcript_path`, `session_id`, `trigger`)
2. Create a backup snapshot: copy the JSONL to `~/.cmv/auto-backups/{session_id}_{timestamp}.jsonl` (rolling, keep last 3 per session)
3. Trim the JSONL **in-place**: run `trimJsonl(transcriptPath, tempPath, { threshold })` then `fs.rename(tempPath, transcriptPath)`
4. Write trim stats to `~/.cmv/auto-trim-log.json` for the `hook status` command
5. Exit 0 (PreCompact hooks have no decision control, just side effects)

In-place trim is safe because:
- We back up first
- `trimJsonl` already produces a valid JSONL
- `fs.rename` is atomic on the same filesystem
- If anything fails, the original file is untouched (we write to temp first)

Timeout is 30s which is more than enough. Trim of a 200k token session takes <1s.

#### 3. New command: `cmv hook restore`

If something goes wrong, the user can restore from the auto-backup:

```
cmv hook restore              # restore the most recent auto-backup
cmv hook restore --list       # show available backups
```

Copies the backup JSONL back to the Claude project directory, overwriting the current session file.

#### 4. Auto-backup management

**File: `src/core/auto-backup.ts`**

- Store backups in `~/.cmv/auto-backups/`
- Filename: `{session_id}_{ISO_timestamp}.jsonl`
- Keep last 3 per session ID (rolling)
- `listBackups(sessionId?)` returns available backups
- `restoreBackup(backupPath, projectDir)` copies back

#### 5. Register in index.ts

- `registerHookCommand(program)` - the `hook` command group with `install`, `uninstall`, `status`, `restore` subcommands
- `registerAutoTrimCommand(program)` - the hidden `auto-trim` command (`.hideHelp()`)

#### 6. TUI integration

Add a status indicator in the Dashboard's detail pane for sessions:
- "Auto-trim: active" if the hook is installed
- Last trim stats if available (reduction %, when)
- Could show this in the DetailPane when viewing a session

#### 7. Settings storage

Add to `~/.cmv/config.json`:

```json
{
  "autoTrim": {
    "enabled": true,
    "threshold": 500,
    "matcher": "auto",
    "maxBackups": 3
  }
}
```

Read by `cmv auto-trim` at runtime.

### Files to create/modify

| File | Action |
|------|--------|
| `src/commands/hook.ts` | Create: install/uninstall/status/restore subcommands |
| `src/commands/auto-trim.ts` | Create: hidden command called by the hook |
| `src/core/auto-backup.ts` | Create: backup management (save, list, restore, rotate) |
| `src/index.ts` | Modify: register both new commands |
| `src/tui/components/DetailPane.tsx` | Modify: show auto-trim status for sessions |
| `src/types/index.ts` | Modify: add AutoTrimConfig type |

### Test plan

- Unit test: `auto-trim` reads stdin JSON, trims the file in-place, writes backup
- Unit test: backup rotation keeps only N most recent
- Unit test: `hook install` writes correct JSON to settings file
- Unit test: `hook uninstall` removes only the CMV entry, leaves other hooks intact
- Integration: install hook, verify settings.json is correct, run `cmv auto-trim` with a mock JSONL piped to stdin

---

## Feature 2: Batch Branching + Session Status

### What it does

Branch multiple times from the same snapshot in one action, and see session status (active/idle/trimmed) in the tree view. Create 3 branches from "analysis", see them all in the tree, pick one to work on, come back and pick the next.

### Implementation

#### 1. Multi-branch action in TUI

New keyboard shortcut in Dashboard: `m` for multi-branch.

Flow:
1. User selects a snapshot, presses `m`
2. Prompt: "Branch names (comma-separated):"
3. User types: `auth-work, api-work, perf-fix`
4. CMV creates 3 branches sequentially (all `noLaunch: true`)
5. Shows status: "Created 3 branches from 'analysis'"
6. Refreshes tree to show all 3

This is simple and uses existing `createBranch`. No new core logic needed.

Each branch gets an orientation line appended to the JSONL as a user message:

```
You are continuing from a branched snapshot called "auth-work", forked from "analysis". Focus area: auth-work.
```

Not a prompt that expects a response. Just context so Claude knows what this fork is for without the user having to re-explain.

**File: `src/tui/Dashboard.tsx`**

- New mode: `'multi-branch-prompt'`
- New handler: `handleMultiBranch(input: string)`
- Splits on comma, trims, calls `createBranch` for each
- New prompt component: `MultiBranchPrompt` (reuse existing prompt pattern)

**File: `src/core/branch-manager.ts`**

- After copying/trimming the JSONL to the new session, append an orientation line
- Format: `{"type":"human","message":{"role":"user","content":"You are continuing from a branched snapshot called \"{branchName}\", forked from \"{snapshotName}\". Focus area: {branchName}."}}`
- Only added during multi-branch (not regular single branch, where the user is about to type their own first message)

#### 2. Session status indicators in TreePane

Currently sessions show: `[id...][msg-count][modified][first-prompt]`

Add a status icon prefix:

```
● active      (mtime < 2 min ago, green)
○ idle        (has session file, not recently modified)
◆ trimmed     (has "trimmed" tag or was created via trim)
```

**File: `src/tui/components/TreePane.tsx`**

- Check `isSessionActive(entry)` for each session node
- Add color-coded prefix character
- For branches, check if parent snapshot has "trimmed" tag

#### 3. Session group view

When a snapshot has multiple branches, show them grouped with an aggregate status line:

```
analysis (snapshot, 2d ago, 82 msgs)
├── auth-work    ● active   42 msgs   2m ago
├── api-work     ○ idle     38 msgs   1h ago
└── perf-fix     ○ idle     15 msgs   3h ago
```

This is already close to what TreePane shows. The additions are:
- Status icon (from step 2)
- Message count for branches (read from session if it exists)
- Relative time

**File: `src/tui/components/TreePane.tsx`**

- When rendering a branch node, look up its `forked_session_id` in the sessions list
- If the session still exists, show msg count + mtime + status icon
- If the session was deleted, show "(deleted)" grayed out

#### 4. Aggregate context view in DetailPane

When a snapshot is selected and has multiple branches, show aggregate stats:

```
Branches: 3
  auth-work    42 msgs   ~85k tokens   ● active
  api-work     38 msgs   ~72k tokens   ○ idle
  perf-fix     15 msgs   ~31k tokens   ○ idle

Total estimated tokens across branches: ~188k
```

**File: `src/tui/components/DetailPane.tsx`**

- When selected node is a snapshot with branches
- For each branch, look up session by `forked_session_id`
- Show per-branch stats in a sub-table
- Show aggregate

### Files to create/modify

| File | Action |
|------|--------|
| `src/tui/Dashboard.tsx` | Modify: add `m` key handler, multi-branch-prompt mode |
| `src/tui/components/TreePane.tsx` | Modify: status icons, branch metadata display |
| `src/tui/components/DetailPane.tsx` | Modify: aggregate branch stats view |
| `src/tui/components/MultiBranchPrompt.tsx` | Create: comma-separated branch name input |
| `src/tui/hooks/useProjects.ts` | Modify: enrich branch nodes with session data |

### Test plan

- Unit test: multi-branch creation from single snapshot (3 branches, all correct parent)
- Unit test: session status detection (active vs idle based on mtime)
- Unit test: branch-to-session lookup (forked_session_id resolution)
- Visual: launch TUI with a snapshot that has 3+ branches, verify status display

---

## Migration and Versioning

### Version bump

- `package.json`: 1.2.0 -> 2.0.0
- `src/index.ts`: 1.2.0 -> 2.0.0

2.0.0 because the hook system is a new integration surface, not just a new command. It changes how CMV interacts with Claude Code (from external tool to integrated hook).

### Breaking changes

None. All existing commands work identically. The hook is opt-in via `cmv hook install`.

### CHANGELOG entry

```
## [2.0.0]

### Added
- `cmv hook install` — registers a PreCompact hook with Claude Code that auto-trims
  sessions before compaction fires. Compaction now summarises clean conversation signal
  instead of 60-70% mechanical overhead.
- `cmv hook uninstall` / `cmv hook status` / `cmv hook restore` — manage the hook lifecycle
  and restore from auto-backups if needed.
- Batch branching from TUI: press `m` on a snapshot to create multiple branches at once
  with orientation messages injected so Claude knows the focus area.
- Session status indicators in tree view (active/idle/trimmed).
- Aggregate branch stats in detail pane when viewing snapshots with multiple branches.
```

---

## Implementation Order

1. **Auto-backup module** (`auto-backup.ts`) — standalone, no dependencies
2. **Auto-trim command** (`auto-trim.ts`) — depends on trimmer + auto-backup
3. **Hook command** (`hook.ts`) — depends on auto-trim command existing
4. **Tests for hook system** — unit tests for all three new files
5. **Multi-branch prompt** (`MultiBranchPrompt.tsx`) — new TUI component
6. **Dashboard multi-branch handler** — wire up `m` key
7. **TreePane status indicators** — session status icons
8. **DetailPane aggregate view** — branch stats display
9. **Tests for TUI features** — multi-branch creation, status detection
10. **README + CHANGELOG updates**

Steps 1-4 (auto-trim hook) and 5-9 (batch branching) are independent and can be done in parallel by two instances if needed.

---

## Architecture Notes for the Implementer

### Key files to read first

- `src/core/trimmer.ts` — the trim logic you'll call from auto-trim
- `src/tui/Dashboard.tsx` — the state machine (modes, key handlers, action handlers)
- `src/tui/components/TreePane.tsx` — how nodes render
- `src/tui/components/DetailPane.tsx` — how detail metadata renders
- `src/core/branch-manager.ts` — `createBranch()` is what multi-branch will call
- `src/utils/process.ts` — `spawnClaudeInteractive()` for understanding launch flow

### Patterns to follow

- Commands: one file per command in `src/commands/`, exported as `registerXCommand(program)`
- TUI prompts: see existing `BranchPrompt` pattern in Dashboard.tsx (mode switch, Esc to cancel, Enter to submit)
- Core modules: pure async functions, no side effects on import, types in `src/types/index.ts`
- Tests: `tests/` directory, vitest, one file per module

### Platform considerations

- `~/.claude/settings.json` path: use `os.homedir()` + `.claude/settings.json`
- Windows: settings.json uses forward slashes internally but the command path in the hook needs to work cross-platform. Use the bare command name `cmv` since it's globally linked.
- The `cmv auto-trim` command reads from stdin. On Windows, piped stdin works fine with `process.stdin`.

---

## v3.0.0 Roadmap: Parallel Session Management

v2.0.0 gives you batch branching and status visibility. v3.0.0 makes the TUI itself host live Claude sessions so you never leave it.

### Core idea

The TUI becomes a two-pane layout: left pane is the navigator (projects, snapshots, sessions), right pane is a live Claude session. You branch, Claude starts in the right pane, you work. Shift+Tab cycles through live sessions. CMV shortcuts only work when the left pane is focused.

### TUI layout

Keeps the existing three-pane Ranger-style layout. The current DetailPane becomes the Claude session pane.

```
┌─ Projects ──────┬─ Navigator ───────────────┬─ Claude Session ──────────────┐
│                  │                           │                               │
│ > my-app         │ Snapshots                 │  auth-work (from: analysis)   │
│   other-project  │ ▼ analysis (82 msgs)      │                               │
│                  │   ├── auth-work   ● Live  │  > read src/auth.ts           │
│                  │   ├── api-work    ○ Idle  │                               │
│ ─── Details ──── │   └── perf-fix   ○ Idle  │  The auth module uses JWT     │
│ analysis         │                           │  with refresh tokens stored   │
│ 82 msgs          │ Sessions                  │  in httpOnly cookies...       │
│ ~148k tokens     │   abc123...  42 msgs      │                               │
│ 67% trimmable    │   def456...  18 msgs      │                               │
│                  │                           │  █                            │
└──────────────────┴───────────────────────────┴───────────────────────────────┘
  Tab: cycle panes    Shift+Tab: cycle live sessions    m: multi-branch
```

- **Left pane**: projects list + detail metadata for selected item (combined into one column)
- **Middle pane**: snapshots (with branches inline, showing Live/Idle) + sessions
- **Right pane**: live Claude session (replaces DetailPane when a session is active)
- **Tab**: cycles focus between all three panes (left, middle, right)
- **Left/middle pane focused**: CMV shortcuts work (b, t, s, d, m, etc.), j/k navigates
- **Right pane focused**: all input goes to Claude, CMV shortcuts disabled
- **Shift+Tab** (right pane focused): cycle through live Claude sessions, header shows snapshot + branch name
- When no session is live, right pane shows the current DetailPane content (context analysis, metadata) as it does today

### What this requires

#### 1. PTY layer

**Dependency: `node-pty`** (native module)

Claude Code is a full terminal app. To embed it, you need a pseudo-terminal:

- Allocate a PTY per Claude session via `node-pty`
- Spawn `claude --resume {id}` inside the PTY
- Capture output stream for rendering in the right pane
- Forward keyboard input from the right pane into the PTY

`node-pty` handles this cross-platform (Windows ConPTY, Unix PTY). It's a native dependency that needs compilation, which adds install complexity. This is the main tradeoff.

#### 2. Terminal renderer component

**File: `src/tui/components/TerminalPane.tsx`**

Ink renders React components, not raw terminal output. Need a component that:

- Receives a stream of PTY output (ANSI-encoded text)
- Parses ANSI sequences into styled Ink `<Text>` elements (use a library like `ansi-to-react` or `strip-ansi` + custom parser)
- Maintains a scrollback buffer (last N lines)
- Handles cursor positioning within the pane bounds
- Re-renders on new output

This is the hardest part. Claude Code's output includes cursor movements, line clearing, progress spinners, and Ink's own rendering. Faithfully reproducing this inside a sub-region is a terminal-in-terminal problem.

**Simplified approach**: don't try to replicate Claude's TUI perfectly. Instead:
- Strip ANSI cursor control sequences
- Keep color/bold/underline formatting
- Render as a scrolling text log
- Accept that spinners and progress bars won't look perfect inside the pane

This gives 80% of the value (you can read Claude's responses and see what it's doing) without building a full terminal emulator.

#### 3. Process manager

**File: `src/core/process-manager.ts`**

- `launchSession(sessionId, cwd)` — spawns Claude in a PTY, returns handle
- `listActive()` — returns live sessions with PID, uptime, buffer content
- `stopSession(sessionId)` — sends SIGTERM, cleans up PTY
- `sendInput(sessionId, data)` — forwards keystrokes to PTY
- `onOutput(sessionId, callback)` — subscribes to output stream
- Track child processes, clean up all PTYs on TUI exit

#### 4. Input routing

**File: `src/tui/Dashboard.tsx`**

When right pane is focused:
- Disable all `useInput` handlers for CMV shortcuts
- Forward raw keystrokes to the active session's PTY via `process-manager.sendInput()`
- Only intercept Tab (switch to left pane) and Shift+Tab (cycle sessions)

When left pane is focused:
- All existing CMV shortcuts work as before
- Right pane continues rendering output but doesn't receive input

#### 5. Session lifecycle

When user presses `Enter` or `m` to launch branches:
- Instead of exiting TUI and spawning Claude externally, spawn in PTY
- Mark session as "Live" in the tree
- Switch focus to right pane automatically
- When Claude session ends (PTY closes), mark as "Idle", switch focus back to left pane

#### 6. Layout restructuring

Current TUI: three columns (ProjectPane, TreePane, DetailPane)

v3.0.0 TUI: three columns (ProjectPane + Details, NavigatorPane, TerminalPane)

- Left pane: merge ProjectPane and DetailPane into one column. Projects at top, detail metadata for the selected item below.
- Middle pane: NavigatorPane. Snapshots (with branches inline, showing Live/Idle) + Sessions. This is the current TreePane but with the snapshot/session split made explicit.
- Right pane: TerminalPane. Live Claude session when active, falls back to current DetailPane content (context analysis) when no session is live.

### What it depends on

- v2.0.0 batch branching (creates the branches)
- v2.0.0 session status indicators (Live/Idle)
- v2.0.0 orientation messages (each session knows its focus)

### Open questions

- **`node-pty` as a dependency**: adds native compilation step to install. Could make `npm install` fail on systems without build tools. Worth it? Or should it be an optional peer dependency that enables the embedded mode?
- **Claude Code's permission prompts**: when Claude asks for permission inside the PTY, the user needs to respond. This should work naturally since input is forwarded, but needs testing.
- **ANSI rendering fidelity**: how much of Claude's TUI output can be faithfully rendered inside a sub-pane? The simplified approach (scrolling text log) may be good enough.
- **Memory**: each PTY + scrollback buffer adds memory overhead. 5 live sessions might be fine, 20 might not. Need to cap or implement buffer eviction.
- **Ink limitations**: Ink redraws the full screen on state changes. With a PTY streaming output, this could cause flickering or performance issues. May need to throttle renders or use `useStdout` directly.
