# CMV v2.0.0 Plan

Two features: auto-trim via Claude Code's hook system, and batch branching with session status in the TUI.

---

## Feature 1: Auto-Trim Hook

### What it does

CMV registers a `PreCompact` hook with Claude Code. When compaction is about to fire (auto or manual), the hook trims the session JSONL before compaction reads it. The mechanical overhead is gone before the summariser ever sees it, so compaction produces a higher quality summary from clean signal instead of 60-70% tool result noise.

### How Claude Code hooks work

Claude Code has a lifecycle hook system configured in `.claude/settings.json` or `~/.claude/settings.json`. Hooks are shell commands that run at specific events. The relevant event is `PreCompact`, which fires before context compaction. It receives JSON on stdin with:

```json
{
  "session_id": "abc123",
  "transcript_path": "/path/to/session.jsonl",
  "trigger": "auto",
  "cwd": "/project/dir"
}
```

`PreCompact` **cannot block compaction** (it always proceeds), but we can modify the transcript file before compaction reads it. We can also create a backup snapshot before any modification happens.

### Implementation

#### 1. New command: `cmv hook install`

Registers the PreCompact hook in the user's Claude Code settings.

**File: `src/commands/hook.ts`**

```
cmv hook install          # install the PreCompact auto-trim hook
cmv hook uninstall        # remove it
cmv hook status           # show whether installed, last trim stats
```

`install` does the following:
- Read `~/.claude/settings.json` (create if missing)
- Add to `hooks.PreCompact`:

```json
{
  "hooks": {
    "PreCompact": [
      {
        "matcher": "auto",
        "hooks": [
          {
            "type": "command",
            "command": "cmv auto-trim",
            "timeout": 30,
            "statusMessage": "CMV: trimming context before compaction..."
          }
        ]
      }
    ]
  }
}
```

- `matcher: "auto"` means it only fires on auto-compaction, not manual `/compact`. Manual compact is intentional. Auto-compact is the one that catches people off guard.
- The hook calls `cmv auto-trim`, a new hidden command.

Options for `install`:
- `--all` to match both `auto` and `manual` triggers
- `--threshold <chars>` to set trim aggressiveness (written to CMV config, read by auto-trim at runtime)

#### 2. New command: `cmv auto-trim` (hidden, not shown in help)

This is the command the hook actually calls. It reads JSON from stdin (the hook input), performs the trim, and exits.

**File: `src/commands/auto-trim.ts`**

Flow:
1. Read JSON from stdin (hook provides `transcript_path`, `session_id`, `trigger`)
2. Create a backup snapshot: copy the JSONL to `~/.cmv/auto-backups/{session_id}_{timestamp}.jsonl` (rolling, keep last 3 per session)
3. Trim the JSONL **in-place**: run `trimJsonl(transcriptPath, tempPath, { threshold })` then `fs.rename(tempPath, transcriptPath)`
4. Write trim stats to `~/.cmv/auto-trim-log.json` for the `hook status` command
5. Exit 0 (PreCompact hooks have no decision control, just side effects)

In-place trim is safe because:
- We back up first
- `trimJsonl` already produces a valid JSONL
- `fs.rename` is atomic on the same filesystem
- If anything fails, the original file is untouched (we write to temp first)

Timeout is 30s which is more than enough. Trim of a 200k token session takes <1s.

#### 3. New command: `cmv hook restore`

If something goes wrong, the user can restore from the auto-backup:

```
cmv hook restore              # restore the most recent auto-backup
cmv hook restore --list       # show available backups
```

Copies the backup JSONL back to the Claude project directory, overwriting the current session file.

#### 4. Auto-backup management

**File: `src/core/auto-backup.ts`**

- Store backups in `~/.cmv/auto-backups/`
- Filename: `{session_id}_{ISO_timestamp}.jsonl`
- Keep last 3 per session ID (rolling)
- `listBackups(sessionId?)` returns available backups
- `restoreBackup(backupPath, projectDir)` copies back

#### 5. Register in index.ts

- `registerHookCommand(program)` - the `hook` command group with `install`, `uninstall`, `status`, `restore` subcommands
- `registerAutoTrimCommand(program)` - the hidden `auto-trim` command (`.hideHelp()`)

#### 6. TUI integration

Add a status indicator in the Dashboard's detail pane for sessions:
- "Auto-trim: active" if the hook is installed
- Last trim stats if available (reduction %, when)
- Could show this in the DetailPane when viewing a session

#### 7. Settings storage

Add to `~/.cmv/config.json`:

```json
{
  "autoTrim": {
    "enabled": true,
    "threshold": 500,
    "matcher": "auto",
    "maxBackups": 3
  }
}
```

Read by `cmv auto-trim` at runtime.

### Files to create/modify

| File | Action |
|------|--------|
| `src/commands/hook.ts` | Create: install/uninstall/status/restore subcommands |
| `src/commands/auto-trim.ts` | Create: hidden command called by the hook |
| `src/core/auto-backup.ts` | Create: backup management (save, list, restore, rotate) |
| `src/index.ts` | Modify: register both new commands |
| `src/tui/components/DetailPane.tsx` | Modify: show auto-trim status for sessions |
| `src/types/index.ts` | Modify: add AutoTrimConfig type |

### Test plan

- Unit test: `auto-trim` reads stdin JSON, trims the file in-place, writes backup
- Unit test: backup rotation keeps only N most recent
- Unit test: `hook install` writes correct JSON to settings file
- Unit test: `hook uninstall` removes only the CMV entry, leaves other hooks intact
- Integration: install hook, verify settings.json is correct, run `cmv auto-trim` with a mock JSONL piped to stdin

---

## Feature 2: Batch Branching + Session Status

### What it does

Branch multiple times from the same snapshot in one action, and see session status (active/idle/trimmed) in the tree view. Create 3 branches from "analysis", see them all in the tree, pick one to work on, come back and pick the next.

### Implementation

#### 1. Multi-branch action in TUI

New keyboard shortcut in Dashboard: `m` for multi-branch.

Flow:
1. User selects a snapshot, presses `m`
2. Prompt: "Branch names (comma-separated):"
3. User types: `auth-work, api-work, perf-fix`
4. CMV creates 3 branches sequentially (all `noLaunch: true`)
5. Shows status: "Created 3 branches from 'analysis'"
6. Refreshes tree to show all 3

This is simple and uses existing `createBranch`. No new core logic needed.

Each branch gets an orientation line appended to the JSONL as a user message:

```
You are continuing from a branched snapshot called "auth-work", forked from "analysis". Focus area: auth-work.
```

Not a prompt that expects a response. Just context so Claude knows what this fork is for without the user having to re-explain.

**File: `src/tui/Dashboard.tsx`**

- New mode: `'multi-branch-prompt'`
- New handler: `handleMultiBranch(input: string)`
- Splits on comma, trims, calls `createBranch` for each
- New prompt component: `MultiBranchPrompt` (reuse existing prompt pattern)

**File: `src/core/branch-manager.ts`**

- After copying/trimming the JSONL to the new session, append an orientation line
- Format: `{"type":"human","message":{"role":"user","content":"You are continuing from a branched snapshot called \"{branchName}\", forked from \"{snapshotName}\". Focus area: {branchName}."}}`
- Only added during multi-branch (not regular single branch, where the user is about to type their own first message)

#### 2. Session status indicators in TreePane

Currently sessions show: `[id...][msg-count][modified][first-prompt]`

Add a status icon prefix:

```
● active      (mtime < 2 min ago, green)
○ idle        (has session file, not recently modified)
◆ trimmed     (has "trimmed" tag or was created via trim)
```

**File: `src/tui/components/TreePane.tsx`**

- Check `isSessionActive(entry)` for each session node
- Add color-coded prefix character
- For branches, check if parent snapshot has "trimmed" tag

#### 3. Session group view

When a snapshot has multiple branches, show them grouped with an aggregate status line:

```
analysis (snapshot, 2d ago, 82 msgs)
├── auth-work    ● active   42 msgs   2m ago
├── api-work     ○ idle     38 msgs   1h ago
└── perf-fix     ○ idle     15 msgs   3h ago
```

This is already close to what TreePane shows. The additions are:
- Status icon (from step 2)
- Message count for branches (read from session if it exists)
- Relative time

**File: `src/tui/components/TreePane.tsx`**

- When rendering a branch node, look up its `forked_session_id` in the sessions list
- If the session still exists, show msg count + mtime + status icon
- If the session was deleted, show "(deleted)" grayed out

#### 4. Aggregate context view in DetailPane

When a snapshot is selected and has multiple branches, show aggregate stats:

```
Branches: 3
  auth-work    42 msgs   ~85k tokens   ● active
  api-work     38 msgs   ~72k tokens   ○ idle
  perf-fix     15 msgs   ~31k tokens   ○ idle

Total estimated tokens across branches: ~188k
```

**File: `src/tui/components/DetailPane.tsx`**

- When selected node is a snapshot with branches
- For each branch, look up session by `forked_session_id`
- Show per-branch stats in a sub-table
- Show aggregate

### Files to create/modify

| File | Action |
|------|--------|
| `src/tui/Dashboard.tsx` | Modify: add `m` key handler, multi-branch-prompt mode |
| `src/tui/components/TreePane.tsx` | Modify: status icons, branch metadata display |
| `src/tui/components/DetailPane.tsx` | Modify: aggregate branch stats view |
| `src/tui/components/MultiBranchPrompt.tsx` | Create: comma-separated branch name input |
| `src/tui/hooks/useProjects.ts` | Modify: enrich branch nodes with session data |

### Test plan

- Unit test: multi-branch creation from single snapshot (3 branches, all correct parent)
- Unit test: session status detection (active vs idle based on mtime)
- Unit test: branch-to-session lookup (forked_session_id resolution)
- Visual: launch TUI with a snapshot that has 3+ branches, verify status display

---

## Migration and Versioning

### Version bump

- `package.json`: 1.2.0 -> 2.0.0
- `src/index.ts`: 1.2.0 -> 2.0.0

2.0.0 because the hook system is a new integration surface, not just a new command. It changes how CMV interacts with Claude Code (from external tool to integrated hook).

### Breaking changes

None. All existing commands work identically. The hook is opt-in via `cmv hook install`.

### CHANGELOG entry

```
## [2.0.0]

### Added
- `cmv hook install` — registers a PreCompact hook with Claude Code that auto-trims
  sessions before compaction fires. Compaction now summarises clean conversation signal
  instead of 60-70% mechanical overhead.
- `cmv hook uninstall` / `cmv hook status` / `cmv hook restore` — manage the hook lifecycle
  and restore from auto-backups if needed.
- Batch branching from TUI: press `m` on a snapshot to create multiple branches at once
  with orientation messages injected so Claude knows the focus area.
- Session status indicators in tree view (active/idle/trimmed).
- Aggregate branch stats in detail pane when viewing snapshots with multiple branches.
```

---

## Implementation Order

1. **Auto-backup module** (`auto-backup.ts`) — standalone, no dependencies
2. **Auto-trim command** (`auto-trim.ts`) — depends on trimmer + auto-backup
3. **Hook command** (`hook.ts`) — depends on auto-trim command existing
4. **Tests for hook system** — unit tests for all three new files
5. **Multi-branch prompt** (`MultiBranchPrompt.tsx`) — new TUI component
6. **Dashboard multi-branch handler** — wire up `m` key
7. **TreePane status indicators** — session status icons
8. **DetailPane aggregate view** — branch stats display
9. **Tests for TUI features** — multi-branch creation, status detection
10. **README + CHANGELOG updates**

Steps 1-4 (auto-trim hook) and 5-9 (batch branching) are independent and can be done in parallel by two instances if needed.

---

## Architecture Notes for the Implementer

### Key files to read first

- `src/core/trimmer.ts` — the trim logic you'll call from auto-trim
- `src/tui/Dashboard.tsx` — the state machine (modes, key handlers, action handlers)
- `src/tui/components/TreePane.tsx` — how nodes render
- `src/tui/components/DetailPane.tsx` — how detail metadata renders
- `src/core/branch-manager.ts` — `createBranch()` is what multi-branch will call
- `src/utils/process.ts` — `spawnClaudeInteractive()` for understanding launch flow

### Patterns to follow

- Commands: one file per command in `src/commands/`, exported as `registerXCommand(program)`
- TUI prompts: see existing `BranchPrompt` pattern in Dashboard.tsx (mode switch, Esc to cancel, Enter to submit)
- Core modules: pure async functions, no side effects on import, types in `src/types/index.ts`
- Tests: `tests/` directory, vitest, one file per module

### Platform considerations

- `~/.claude/settings.json` path: use `os.homedir()` + `.claude/settings.json`
- Windows: settings.json uses forward slashes internally but the command path in the hook needs to work cross-platform. Use the bare command name `cmv` since it's globally linked.
- The `cmv auto-trim` command reads from stdin. On Windows, piped stdin works fine with `process.stdin`.

---

## v3.0.0 Roadmap: Parallel Session Management

Batch branching (v2.0.0) creates multiple branches but you still work on them one at a time. v3.0.0 makes them run simultaneously with live visibility from the TUI.

### Core idea

Select a snapshot, branch 3 times, all 3 Claude instances launch and run in parallel. The TUI stays open and shows live status for each. You can watch progress, switch focus, and see when each finishes.

### What this requires

#### 1. Process manager

**File: `src/core/process-manager.ts`**

Replace the current `spawnClaudeInteractive` (which blocks until exit) with a pool that manages multiple background Claude processes.

- `launchSession(sessionId, cwd)` — spawns `claude --resume {id}` as a background child process
- `listActive()` — returns running sessions with PID, uptime, last output timestamp
- `stopSession(sessionId)` — sends SIGTERM gracefully
- `onOutput(sessionId, callback)` — stream stdout/stderr for live display
- Track child processes, clean up on TUI exit

#### 2. TUI split view

The TUI currently exits before launching Claude. For parallel mode, the TUI stays open and shows a session panel.

Two possible approaches:

**Option A: Status-only (simpler)**
- TUI stays as the launcher/dashboard
- Shows live status per session: running/idle/finished, message count, elapsed time
- Sessions run headless (no visible terminal output in TUI)
- User attaches to a specific session by pressing Enter (exits TUI, resumes interactively)

**Option B: Live output panes (harder)**
- TUI splits into a tree panel + output panel
- Output panel shows streaming text from the selected session
- Tab/number keys to switch which session's output is visible
- Input line at the bottom to send messages to the active session

Option A is realistic. Option B is building a terminal multiplexer inside Ink, which is possible but substantially more complex.

#### 3. Terminal multiplexing (alternative to Option B)

Instead of building split panes in Ink, delegate to tmux/Windows Terminal tabs:

- `cmv launch --parallel auth-work api-work perf-fix`
- On Linux/macOS: creates a tmux session with 3 panes, each running `claude --resume {id}`
- On Windows: opens new Windows Terminal tabs via `wt` command
- `cmv` TUI remains in the original pane/tab as the dashboard

This sidesteps the "build a terminal emulator" problem entirely. Platform detection:
- `tmux` available → use tmux split-window
- `wt.exe` available → use Windows Terminal tabs
- Neither → fall back to sequential (v2.0.0 behavior)

#### 4. Session coordination

When multiple sessions branch from the same snapshot and work on the same codebase:

- File conflict detection: if two sessions edit the same file, flag it in the TUI
- Completion detection: watch for session exit or idle timeout
- Summary view: when all sessions finish, show a recap of what each branch accomplished (parse last assistant message from each JSONL)

This is NOT orchestration (no task decomposition, no agent hierarchy). Each session is independent. The coordination is just visibility and conflict awareness.

### What it depends on

- v2.0.0 batch branching (creates the branches)
- v2.0.0 session status indicators (shows active/idle)
- v2.0.0 orientation messages (each session knows its focus)

### Open questions

- Does `claude --resume` work headlessly (no TTY)? If not, Option B and the process manager need a PTY layer.
- How to handle Claude's permission prompts in headless sessions? May need `--dangerously-skip-permissions` or auto-accept hooks.
- tmux approach ties to Unix. Windows Terminal's `wt` command is the equivalent but the API is different. How much platform-specific code is acceptable?
- Is Ink capable of rendering streaming terminal output from child processes, or does this need a different TUI framework (blessed, terminal-kit)?
